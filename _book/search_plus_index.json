{"./":{"url":"./","title":"Introduction","keywords":"","body":"Summary 介绍 本书籍主要为个人平时个人学习的笔记记录，部分文章会发布到本人博客中去，博客地址 工程工具 git链接多个账号 git学习代码 spark学习笔记 jupyter带目录 学习链接备用点 vim配置 机器学习 xgboost参数和原理 自然语言处理 topic_word_embedings论文解读和实现 代码示例 matplotlib基本绘图示例 sklearn聚类demo gitbook的基本使用 前言 安装 命令 目录结构 配置 插件 主题 bookjson "},"工程工具/git连接多个账号.html":{"url":"工程工具/git连接多个账号.html","title":"git链接多个账号","keywords":"","body":"1、说明 在很多情况下我们在公司使用git需要连接公司的账号，但是如果这个时候需要连接自己的github账号的时候，这个时候就需要在自己电脑上使用git链接两个账号或者多个账号 2、生产两个ssh-key 代码如下 $ ssh-keygen -t rsa -C \"one@gmail.com\" #你的github账号 $ ssh-keygen -t rsa -C \"two@gmail.com\" #你的github账号 注意： 不要一路回车，分别在第一个对话即需要输入的时候,输入文件名（如:id_rsa_one和id_rsa_two），这样会生成对应的文件名的公钥和私钥(如：id_rsa_one、id_rsa_one.pub、id_rsa_two、id_rsa_two.pub) 如果执行的路径不在~/.ssh路径中执行的话，需要把文件拷贝到期目录下 3、添加私钥 打开ssh-agent 如果你是github官方的bash：$ ssh-agent -s 如果你是其它，比如msysgit：$ eval $(ssh-agent -s) 添加私钥 $ ssh-add ~/.ssh/id_rsa_one $ ssh-add ~/.ssh/id_rsa_two 4、创建或者修改config文件 在~/.ssh中如果没有config则使用touch config创建该文件，有的话则进行如下修改: 网上demo示例 # one(one@gmail.com) Host one.github.com 　　HostName github.com 　　PreferredAuthentications publickey 　　IdentityFile ~/.ssh/id_rsa_one 　　User one # two(two@ gmail.com) Host two.github.com 　　HostName github.com 　　PreferredAuthentications publickey 　　IdentityFile ~/.ssh/id_rsa_two 　　User two 自己电脑的示例(配置了gitlab和两个github账号) Host github.com HostName github.com User git IdentityFile /Users/xiachi/.ssh/id_rsa_public Host mayexia HostName github.com User git IdentityFile /Users/xiachi/.ssh/id_rsa_350 Host gitlab.com HostName gitlab.com User git IdentityFile /Users/xiachi/.ssh/id_rsa 最后想连接github的话，需要将对应的公钥添加到github的ssh秘钥中,添加后便可使用git连接到github了。 "},"工程工具/git学习代码.html":{"url":"工程工具/git学习代码.html","title":"git学习代码","keywords":"","body":"Git全局配置 git config --global user.name \"夏驰\" git config --global user.email \"xiachi@github.com\" 创建一个新的仓库 git clone git@github.com:xiachi/code.git cd code touch README.md git add README.md git commit -m \"add README\" git push -u origin master 从已知文件夹上传到仓库 cd existing_folder git init git remote add origin git@github.com:xiachi/code.git git add . git commit -m \"Initial commit\" git push -u origin master 已知的本地仓库 cd existing_repo git remote add origin git@github.com:xiachi/code.git git push -u origin --all git push -u origin --tags "},"工程工具/spark学习笔记.html":{"url":"工程工具/spark学习笔记.html","title":"spark学习笔记","keywords":"","body":"1、小知识点 读取csv文件val vocDF = spark.sqlContext.read.format(\"com.databricks.spark.csv\").option(\"header\", true).load(vocabulary_name) 保存结果到csvdef saveDataFrameAsCsv(df: DataFrame, path: String = \"sample.csv\"): Unit = { val saveOptions = Map(\"header\" -> \"true\", \"path\" -> path) df.write.format(\"com.databricks.spark.csv\").mode(SaveMode.Overwrite).options(saveOptions).save() } "},"工程工具/jupyter安装目录工具.html":{"url":"工程工具/jupyter安装目录工具.html","title":"jupyter带目录","keywords":"","body":"1. 安装 jupyter_contrib_nbextensions pip install jupyter_contrib_nbextensions 2. 配置 nbextension jupyter contrib nbextension install --user 3. 启动jupyter notebook 选择 Nbextensions 勾选 Table of Contents 4. 官方链接如下 jupyter_contrib_nbextensions安装 "},"工程工具/学习链接备用点.html":{"url":"工程工具/学习链接备用点.html","title":"学习链接备用点","keywords":"","body":"工程工具 fastText参数 Hive函数大全 hadoop(r1.0.4)中文官方文档 spark中文文档 facebook开源的词向量 Scikit-learn中文文档知乎链接入口 sklearn中文文档 17款工具让数据更美观 算法学习 知网定义 LDA原理浅析 xgboost原理(陈天奇) 解读论文Topical Word Embeddings 刘知远老师博士论文 知识图谱综述 机器学习基础干货 文本特征选择论文 DBSCAN聚类算法的理论 DBSCAN聚类算法的sklearn实现 知识图谱论文 方法论 初学者如何查阅自然语言处理（NLP）领域学术资料 文本分类之特征选择 结合Scikit-learn介绍几种常用的特征选择方法 聚类算法分析 机器学习中的数据清洗与特征处理综述 模型融合方法概述(kaggle比赛心得) 推荐搜索等AI架构 百度语义相似度匹配说明 文档聚类算法 sklearn特征工程 文本分类及很多nlp的相关语料知识链接 项目Demo学习 nlp文本分类练手小项目 TensorFlow-Examples 免费资源 google家Colaboratory开源GPU机器的资源 "},"工程工具/vim配置.html":{"url":"工程工具/vim配置.html","title":"vim配置","keywords":"","body":"配置代码如下 \" 定义快捷键的前缀，即 let mapleader=\";\" \" >> \" 文件类型侦测 \" 开启文件类型侦测 filetype on \" 根据侦测到的不同类型加载对应的插件 filetype plugin on \" > \" vim 自身（非插件）快捷键 \" 定义快捷键到行首和行尾 nmap LB 0 nmap LE $ \" 设置快捷键将选中文本块复制至系统剪贴板 vnoremap y \"+y \" 设置快捷键将系统剪贴板内容粘贴至vim nmap p \"+p \" 定义快捷键关闭当前分割窗口 nmap q :q \" 定义快捷键保存当前窗口内容 nmap w :w \" 定义快捷键保存所有窗口内容并退出 vim nmap WQ :wa:q \" 不做任何保存，直接退出 vim nmap Q :qa! \" 设置快捷键遍历子窗口 \" 依次遍历 nnoremap nw \" 跳转至右方的窗口 nnoremap lw l \" 跳转至方的窗口 nnoremap hw h \" 跳转至上方的子窗口 nnoremap kw k \" 跳转至下方的子窗口 nnoremap jw j \" 定义快捷键在结对符之间跳转 nmap M % \" > \" 其他 \" 开启实时搜索功能 set incsearch \" 搜索时大小写不敏感 set ignorecase \" 关闭兼容模式 set nocompatible \" vim 自身命令行模式智能补全 set wildmenu \" >>> \" 插件安装 \" vundle 环境设置 filetype off set rtp+=~/.vim/bundle/Vundle.vim \" vundle 管理的插件列表必须位于 vundle#begin() 和 vundle#end() 之间 call vundle#begin() Plugin 'VundleVim/Vundle.vim' Plugin 'altercation/vim-colors-solarized' Plugin 'tomasr/molokai' Plugin 'vim-scripts/phd' Plugin 'Lokaltog/vim-powerline' Plugin 'octol/vim-cpp-enhanced-highlight' Plugin 'nathanaelkane/vim-indent-guides' Plugin 'derekwyatt/vim-fswitch' Plugin 'kshenoy/vim-signature' Plugin 'vim-scripts/BOOKMARKS--Mark-and-Highlight-Full-Lines' Plugin 'majutsushi/tagbar' Plugin 'vim-scripts/indexer.tar.gz' Plugin 'vim-scripts/DfrankUtil' Plugin 'vim-scripts/vimprj' Plugin 'dyng/ctrlsf.vim' Plugin 'terryma/vim-multiple-cursors' Plugin 'scrooloose/nerdcommenter' Plugin 'vim-scripts/DrawIt' Plugin 'SirVer/ultisnips' Plugin 'Valloric/YouCompleteMe' Plugin 'derekwyatt/vim-protodef' Plugin 'scrooloose/nerdtree' Plugin 'fholgado/minibufexpl.vim' Plugin 'gcmt/wildfire.vim' Plugin 'sjl/gundo.vim' Plugin 'Lokaltog/vim-easymotion' Plugin 'suan/vim-instant-markdown' Plugin 'lilydjwg/fcitx.vim' \" 插件列表结束 call vundle#end() filetype plugin indent on \" > \" 营造专注气氛 \" 禁止光标闪烁 set gcr=a:block-blinkon0 \" 禁止显示滚动条 set guioptions-=l set guioptions-=L set guioptions-=r set guioptions-=R \" 禁止显示菜单和工具条 set guioptions-=m set guioptions-=T \" 将外部命令 wmctrl 控制窗口最大化的命令行参数封装成一个 vim 的函数 fun! ToggleFullscreen() call system(\"wmctrl -ir \" . v:windowid . \" -b toggle,fullscreen\") endf \" 全屏开/关快捷键 map :call ToggleFullscreen() \"\" 启动 vim 时自动全屏 \"autocmd VimEnter * call ToggleFullscreen() \" > \" 辅助信息 \" 总是显示状态栏 set laststatus=2 \" 显示光标当前位置 set ruler \" 开启行号显示 set number \" 高亮显示当前行/列 set cursorline set cursorcolumn \" 高亮显示搜索结果 set hlsearch \" > \" 其他美化 \" 设置 gvim 显示字体 set guifont=YaHei\\ Consolas\\ Hybrid\\ 10.5 \" 禁止折行 set nowrap \" 设置状态栏主题风格 let g:Powerline_colorscheme='solarized256' \" > \" 语法分析 \" 开启语法高亮功能 syntax enable \" 允许用指定语法高亮配色方案替换默认方案 syntax on \" > \" 缩进 \" 自适应不同语言的智能缩进 filetype indent on \" 将制表符扩展为空格 set expandtab \" 设置编辑时制表符占用空格数 set tabstop=4 \" 设置格式化时制表符占用空格数 set shiftwidth=4 \" 让 vim 把连续数量的空格视为一个制表符 set softtabstop=4 \" 缩进可视化插件 Indent Guides \" 随 vim 自启动 let g:indent_guides_enable_on_vim_startup=1 \" 从第二层开始可视化显示缩进 let g:indent_guides_start_level=2 \" 色块宽度 let g:indent_guides_guide_size=1 \" 快捷键 i 开/关缩进可视化 nmap i IndentGuidesToggle \" > \" 代码折叠 \" 基于缩进或语法进行代码折叠 \"set foldmethod=indent set foldmethod=syntax \" 启动 vim 时关闭折叠代码 set nofoldenable \" > \" 接口与实现快速切换 \" *.cpp 和 *.h 间切换 nmap sw :FSHere \" > \" 代码收藏 \" 自定义 vim-signature 快捷键 let g:SignatureMap = { \\ 'Leader' : \"m\", \\ 'PlaceNextMark' : \"m,\", \\ 'ToggleMarkAtLine' : \"m.\", \\ 'PurgeMarksAtLine' : \"m-\", \\ 'DeleteMark' : \"dm\", \\ 'PurgeMarks' : \"mda\", \\ 'PurgeMarkers' : \"m\", \\ 'GotoNextLineAlpha' : \"']\", \\ 'GotoPrevLineAlpha' : \"'[\", \\ 'GotoNextSpotAlpha' : \"`]\", \\ 'GotoPrevSpotAlpha' : \"`[\", \\ 'GotoNextLineByPos' : \"]'\", \\ 'GotoPrevLineByPos' : \"['\", \\ 'GotoNextSpotByPos' : \"mn\", \\ 'GotoPrevSpotByPos' : \"mp\", \\ 'GotoNextMarker' : \"[+\", \\ 'GotoPrevMarker' : \"[-\", \\ 'GotoNextMarkerAny' : \"]=\", \\ 'GotoPrevMarkerAny' : \"[=\", \\ 'ListLocalMarks' : \"ms\", \\ 'ListLocalMarkers' : \"m?\" \\ } \" > \" 标签列表 \" 设置 tagbar 子窗口的位置出现在主编辑区的左边 let tagbar_left=1 \" 设置显示／隐藏标签列表子窗口的快捷键。速记：identifier list by tag nnoremap ilt :TagbarToggle \" 设置标签子窗口的宽度 let tagbar_width=32 \" tagbar 子窗口中不显示冗余帮助信息 let g:tagbar_compact=1 \" 设置 ctags 对哪些代码标识符生成标签 let g:tagbar_type_cpp = { \\ 'ctagstype' : 'c++', \\ 'kinds' : [ \\ 'c:classes:0:1', \\ 'd:macros:0:1', \\ 'e:enumerators:0:0', \\ 'f:functions:0:1', \\ 'g:enumeration:0:1', \\ 'l:local:0:1', \\ 'm:members:0:1', \\ 'n:namespaces:0:1', \\ 'p:functions_prototypes:0:1', \\ 's:structs:0:1', \\ 't:typedefs:0:1', \\ 'u:unions:0:1', \\ 'v:global:0:1', \\ 'x:external:0:1' \\ ], \\ 'sro' : '::', \\ 'kind2scope' : { \\ 'g' : 'enum', \\ 'n' : 'namespace', \\ 'c' : 'class', \\ 's' : 'struct', \\ 'u' : 'union' \\ }, \\ 'scope2kind' : { \\ 'enum' : 'g', \\ 'namespace' : 'n', \\ 'class' : 'c', \\ 'struct' : 's', \\ 'union' : 'u' \\ } \\ } \" > \" 代码导航 \" 基于标签的代码导航 \" 设置插件 indexer 调用 ctags 的参数 \" 默认 --c++-kinds=+p+l，重新设置为 --c++-kinds=+l+p+x+c+d+e+f+g+m+n+s+t+u+v \" 默认 --fields=+iaS 不满足 YCM 要求，需改为 --fields=+iaSl let g:indexer_ctagsCommandLineOptions=\"--c++-kinds=+l+p+x+c+d+e+f+g+m+n+s+t+u+v --fields=+iaSl --extra=+q\" \" 正向遍历同名标签 nmap tn :tnext \" 反向遍历同名标签 nmap tp :tprevious \" 基于语义的代码导航 nnoremap jc :YcmCompleter GoToDeclaration \" 只能是 #include 或已打开的文件 nnoremap jd :YcmCompleter GoToDefinition \" > \" 查找 \" 使用 ctrlsf.vim 插件在工程内全局查找光标所在关键字，设置快捷键。快捷键速记法：search in project nnoremap sp :CtrlSF \" > \" 内容替换 \" 快捷替换 let g:multi_cursor_next_key='' let g:multi_cursor_skip_key='' \" 精准替换 \" 替换函数。参数说明： \" confirm：是否替换前逐一确认 \" wholeword：是否整词匹配 \" replace：被替换字符串 function! Replace(confirm, wholeword, replace) wa let flag = '' if a:confirm let flag .= 'gec' else let flag .= 'ge' endif let search = '' if a:wholeword let search .= '\\'), '/\\.*$^~[') . '\\>' else let search .= expand('') endif let replace = escape(a:replace, '/\\&~') execute 'argdo %s/' . search . '/' . replace . '/' . flag . '| update' endfunction \" 不确认、非整词 nnoremap R :call Replace(0, 0, input('Replace '.expand('').' with: ')) \" 不确认、整词 nnoremap rw :call Replace(0, 1, input('Replace '.expand('').' with: ')) \" 确认、非整词 nnoremap rc :call Replace(1, 0, input('Replace '.expand('').' with: ')) \" 确认、整词 nnoremap rcw :call Replace(1, 1, input('Replace '.expand('').' with: ')) nnoremap rwc :call Replace(1, 1, input('Replace '.expand('').' with: ')) \" \" let g:UltiSnipsJumpForwardTrigger=\"\" let g:UltiSnipsJumpBackwardTrigger=\"\" \" >> \" YCM 补全 \" YCM 补全菜单配色 \" 菜单 highlight Pmenu ctermfg=2 ctermbg=3 guifg=#005f87 guibg=#EEE8D5 \" 选中项 highlight PmenuSel ctermfg=2 ctermbg=3 guifg=#AFD700 guibg=#106900 \" 补全功能在注释中同样有效 let g:ycm_complete_in_comments=1 \" 允许 vim 加载 .ycm_extra_conf.py 文件，不再提示 let g:ycm_confirm_extra_conf=0 \" 开启 YCM 标签补全引擎 let g:ycm_collect_identifiers_from_tags_files=0 \"\" 引入 C++ 标准库 tags \"set tags+=/data/misc/software/app/vim/stdcpp.tags \"set tags+=/data/misc/software/app/vim/sys.tags \" YCM 集成 OmniCppComplete 补全引擎，设置其快捷键 inoremap ; \" 补全内容不以分割子窗口形式出现，只显示补全列表 set completeopt-=preview \" 从第一个键入字符就开始罗列匹配项 let g:ycm_min_num_of_chars_for_completion=1 \" 禁止缓存匹配项，每次都重新生成匹配项 let g:ycm_cache_omnifunc=0 \" 语法关键字补全 let g:ycm_seed_identifiers_with_syntax=1 \" > \" 由接口快速生成实现框架 \" 成员函数的实现顺序与声明顺序一致 let g:disable_protodef_sorting=1 \" > \" 库信息参考 \" 启用:Man命令查看各类man信息 source $VIMRUNTIME/ftplugin/man.vim \" 定义:Man命令查看各类man信息的快捷键 nmap man :Man 3 \" > \" 工程文件浏览 \" 使用 NERDTree 插件查看工程文件。设置快捷键，速记：file list nmap fl :NERDTreeToggle \" 设置 NERDTree 子窗口宽度 let NERDTreeWinSize=22 \" 设置 NERDTree 子窗口位置 let NERDTreeWinPos=\"right\" \" 显示隐藏文件 let NERDTreeShowHidden=1 \" NERDTree 子窗口中不显示冗余帮助信息 let NERDTreeMinimalUI=1 \" 删除文件时自动删除文件对应 buffer let NERDTreeAutoDeleteBuffer=1 \" > \" 多文档编辑 \" 显示/隐藏 MiniBufExplorer 窗口 map bl :MBEToggle \" buffer 切换快捷键 map :MBEbn map :MBEbp \" > \" 环境恢复 \" 设置环境保存项 set sessionoptions=\"blank,globals,localoptions,tabpages,sesdir,folds,help,options,resize,winpos,winsize\" \" 保存 undo 历史。必须先行创建 .undo_history/ set undodir=~/.undo_history/ set undofile \" 保存快捷键 \"map ss :mksession! my.vim :wviminfo! my.viminfo map ss :mksession! my.vim \" 恢复快捷键 \"map rs :source my.vim :rviminfo my.viminfo map rs :source my.vim \" m :wa :cd build/ :!rm -rf main :!cmake CMakeLists.txt:make :cw :cd .. nmap g :wa:cd build/:!rm -rf main:!cmake CMakeLists.txt:make:cw:cd ..:!build/main \" >> \" 快速选中结对符内的文本 \" 快捷键 map (wildfire-fuel) vmap (wildfire-water) \" 适用于哪些结对符 let g:wildfire_objects = [\"i'\", 'i\"', \"i)\", \"i]\", \"i}\", \"i>\", \"ip\"] \" ud :GundoToggle "},"机器学习/xgboost参数和原理.html":{"url":"机器学习/xgboost参数和原理.html","title":"xgboost参数和原理","keywords":"","body":"1、XGBoost参数 在运行XGBoost程序之前，必须设置三种类型的参数：通用类型参数（general parameters）、booster参数和学习任务参数（task parameters）。 一般类型参数general parameters –参数决定在提升的过程中用哪种booster，常见的booster有树模型和线性模型。 Booster参数-该参数的设置依赖于我们选择哪一种booster模型。 学习任务参数task parameters-参数的设置决定着哪一种学习场景，例如，回归任务会使用不同的参数来控制着排序任务。 命令行参数-一般和xgboost的CL版本相关。 1.1Booster参数： eta[默认是0.3] 和GBM中的learning rate参数类似。通过减少每一步的权重，可以提高模型的鲁棒性。典型值0.01-0.2 min_child_weight[默认是1] 决定最小叶子节点样本权重和。当它的值较大时，可以避免模型学习到局部的特殊样本。但如果这个值过高，会导致欠拟合。这个参数需要用cv来调整 max_depth [默认是6] 树的最大深度，这个值也是用来避免过拟合的3-10 max_leaf_nodes 树上最大的节点或叶子的数量，可以代替max_depth的作用，应为如果生成的是二叉树，一个深度为n的树最多生成2n个叶子,如果定义了这个参数max_depth会被忽略 gamma[默认是0] 在节点分裂时，只有在分裂后损失函数的值下降了，才会分裂这个节点。Gamma指定了节点分裂所需的最小损失函数下降值。这个参数值越大，算法越保守。 max_delta_step[默认是0] 这参数限制每颗树权重改变的最大步长。如果是0意味着没有约束。如果是正值那么这个算法会更保守，通常不需要设置。 subsample[默认是1] 这个参数控制对于每棵树，随机采样的比例。减小这个参数的值算法会更加保守，避免过拟合。但是这个值设置的过小，它可能会导致欠拟合。典型值：0.5-1 colsample_bytree[默认是1] 用来控制每颗树随机采样的列数的占比每一列是一个特征0.5-1 colsample_bylevel[默认是1] 用来控制的每一级的每一次分裂，对列数的采样的占比。 lambda[默认是1] 权重的L2正则化项 alpha[默认是1] 权重的L1正则化项 scale_pos_weight[默认是1] 各类样本十分不平衡时，把这个参数设置为一个正数，可以使算法更快收敛。 1.2通用参数 booster[默认是gbtree] 选择每次迭代的模型，有两种选择：gbtree基于树的模型、gbliner线性模型 silent[默认是0] 当这个参数值为1的时候，静默模式开启，不会输出任何信息。一般这个参数保持默认的0，这样可以帮我们更好的理解模型。 nthread[默认值为最大可能的线程数]这个参数用来进行多线程控制，应当输入系统的核数，如果你希望使用cpu全部的核，就不要输入这个参数，算法会自动检测。 1.3学习目标参数： objective[默认是reg：linear] 这个参数定义需要被最小化的损失函数。最常用的值有：binary：logistic二分类的逻辑回归，返回预测的概率非类别。multi:softmax使用softmax的多分类器，返回预测的类别。在这种情况下，你还要多设置一个参数：num_class类别数目。 eval_metric[默认值取决于objective参数的取之] 对于有效数据的度量方法。对于回归问题，默认值是rmse，对于分类问题，默认是error。典型值有：rmse均方根误差；mae平均绝对误差；logloss负对数似然函数值；error二分类错误率；merror多分类错误率；mlogloss多分类损失函数；auc曲线下面积。 seed[默认是0]随机数的种子，设置它可以复现随机数据的结果，也可以用于调整参数。 2、spark的相关代码 训练代码 import ml.dmlc.xgboost4j.scala.spark.XGBoost import ml.dmlc.xgboost4j.scala.spark.XGBoostModel import org.apache.spark.sql.{DataFrame, SaveMode, SparkSession} import org.apache.spark.ml.linalg.{DenseVector, Vector, Vectors} import ml.dmlc.xgboost4j.scala.spark.XGBoostClassificationModel import ml.dmlc.xgboost4j.scala.{Booster, XGBoost => SXGBoost} import org.apache.spark.mllib.evaluation.BinaryClassificationMetrics def train(spark:SparkSession,featuresDF:DataFrame,params_map:Map[String,String]): XGBoostModel ={ val sc = spark.sparkContext val model_name = params_map(\"model_name\").toString val tree_deep = params_map(\"tree_deep\").toString.toInt val tree_num = params_map(\"tree_num\").toString.toInt val lr = params_map(\"lr\").toString.toDouble val scale_pos_weight = params_map(\"scale_pos_weight\").toString.toInt val lambda_value = params_map(\"lambda_value\").toString.toDouble val colsample_bytree = params_map(\"colsample_bytree\").toString.toDouble val n_workers = params_map(\"n_workers\").toString.toInt val seed_max = params_map(\"seed\").toString.toInt val seed = scala.util.Random.nextInt(seed_max) val gamma = params_map.get(\"gamma\").getOrElse(\"0.0\").toString.toFloat val objective = \"binary:logistic\" val paramMap = List( \"eta\" -> lr, \"max_depth\" -> tree_deep, \"lambda\" -> lambda_value, \"objective\" -> objective, \"scale_pos_weight\" -> scale_pos_weight, \"colsample_bytree\" -> colsample_bytree, \"subsample\"->0.75, \"seed\" -> seed).toMap var xgboostModel = XGBoost.trainWithDataFrame(featuresDF, paramMap, tree_num, nWorkers = n_workers, useExternalMemory = true) val model_name_hadoop = model_name + \"_hadoop\" xgboostModel.saveModelAsHadoopFile(model_name_hadoop)(sc) return xgboostModel } 预测代码 def predict(spark:SparkSession,featuresDF:DataFrame,xgboostModel:XGBoostModel): Unit ={ import spark.implicits._ val sc = spark.sparkContext val predict_test = xgboostModel.transform(featuresDF) val prob_label_df = predict_test.map{x=> val label = x.getAs(\"label\").toString.toDouble val probabilities = x.getAs[DenseVector](\"probabilities\").toArray(1) (probabilities,label) } //auc计算 val dataset_metric = new BinaryClassificationMetrics(prob_label_df.rdd) val dataset_auc = dataset_metric.areaUnderROC() println(\"dataset auc:\" + dataset_auc) //ks计算 val ks_result = computer(prob_label_df,20,sc) val ksMax = ks_result._1 val ksInfosDF = ks_result._2.toList.toDF(\"level\", \"good\", \"bad\", \"numGood\", \"numBad\", \"pctGood\", \"pctBad\", \"ks\", \"pBad\", \"scoreMin\", \"scoreMean\", \"scoreMax\", \"len\", \"pBad2Total\") ksInfosDF.show() println(\"最大ks:\",ksMax) } 模型加载 /** * 从hadoop模型文件中加载模型,返回模型对象 * @param spark * @param model_name * @return */ def loadModelWithHadoopFile(spark:SparkSession,model_name:String): XGBoostModel ={ val model_name_hadoop = model_name + \"_hadoop\" val sc = spark.sparkContext val xgboostModel = XGBoost.loadModelFromHadoopFile(model_name_hadoop)(sc) return xgboostModel } /** * 从python版本训练的模型文件加载模型对象 * @param spark * @param model_name * @return */ def loadModel(spark:SparkSession,model_name:String): XGBoostClassificationModel ={ val xgboostModel = new XGBoostClassificationModel(SXGBoost.loadModel(model_name)) return xgboostModel } "},"自然语言处理/topic_word_embedings模型和实现.html":{"url":"自然语言处理/topic_word_embedings模型和实现.html","title":"topic_word_embedings论文解读和实现","keywords":"","body":"一、模型论文解读 论文:《Topical Word Embeddings》 Liu Y, Liu Z, Chua T S, et al. 2015. 1、摘要 大多数词嵌入模型通常使用单个向量来表示每个单词，因此这些模型无法区分同音异义和的一词多义的情况。为了增强判别性，我们采用潜在的主题模型为文本语料库中的每个词分配主题，并基于词和主题来学习主题词嵌入（TWE），这样我们可以灵活地获得情景词嵌入，来衡量情景中单词相似性。我们还可以构建文档的向量表示，这比一些广泛使用的文档模型（如潜在主题模型）更具有表现力。在实验中，我们评估TWE模型的两个任务：情景单词相似性和文本分类。实验结果表明，我们的模型比典型的词嵌入（包括基于上下文的词相似度的多种原型版本）表现更好，同时也优于文本分类的潜在主题模型和其他代表性文档模型。 论文的代码实现地址:topic word embeddings 2、介绍 词嵌入（word embedding），也被称为词表示（ word representation），在基于语料库的上下文构建连续词向量中起着越来越重要的作用。词嵌入既能捕捉单词的语义信息，又能捕捉单词的相似性，因此广泛应用于各种IR和NLP任务中。 大多数词嵌入方法都是假定用每个词能够用单个向量代表，但是无法解决一词多义和同音异议的问题。多原型向量空间模型（Reisinger and Mooney 2010）是将一个单词的上下文分成不同的群（groups），然后为每个群生成不同的原型向量。遵循这个想法， （Huang et al. 2012） 提出了基于神经语言模型（Bengio et al. 2003）的多原型词嵌入。 尽管这些模型是有用的，但是多原型词嵌入面临以下几个挑战：（1）这些模型孤立地为每个词生成多原型向量，忽略了词之间复杂的相关性和它们的上下文。（2）在多原型设置中，一个单词的上下文被分成没有重叠的簇，而实际上，一个词的几个意义可能是相互关联的，它们之间没有明确的语义边界。 在本文中，我们提出了一个更加灵活更加强大的多原型单词嵌入框架——主题词嵌入（TWE），其中主题词是指以特定主题为背景的词。TWE的基本思想是，允许每个词在不同的主题下有不同的嵌入向量。例如，“苹果”这个词在食物主题下表示一个水果，而在IT主题下代表一个IT公司。 我们使用LDA（Blei, Ng, and Jordan 2003）来获取单词主题，执行collapsed Gibbs sampling （Griffiths and Steyvers 2004）来迭代地为每个单词令牌分配潜在的主题。这样，给定一个单词序列D={w1,...,wM}，在使用LDA收敛后，每个单词wi 被分配给一个特定的主题zi，形成一个单词-主题对⟨wi,zi⟩，用来学习主题词嵌入。我们设计了三种TWE模型来学习主题词向量，如图1所示，其中，窗口大小是1，wi−1和wi+1是wi的上下文单词。 论文解读地址 二、代码实现 1、源码下载 github地址 2、topic word embedings使用方式 代码中有三种实现方式，分别在TWE-1、TWE-2、TWE-3中，三种方式都非常依赖其他的库，使用方式如下： 代码依赖于gibbslda++(LDA的c++实现方式)，使用其生成tassign文件和wordmap.txt文件，然后工后续代码使用,如何获取该文件见下文中gibbslda++的使用 使用命令python train.py wordmap_filename tassign_filename topic_number运行程序 输出文件在文件夹output中,分别为:word_vector.txt 和topic_vector.txt 3、gibbslda++使用方式 下载地址 (1) 将文件放在linux下，然后执行如下命令: cd /home/user/LDA/ gunzip GibbsLDA++-0.2.tar.gz tar -xf GibbsLDA++-0.2.tar cd \\GibbsLDA++-0.2 (2) 执行如下命令 make clean make (3) 在执行命令后会出现报错，按照如下操作进行修改 在src/utill.cpp 文件头加入： include #include 在src/utill.h 文件头加入： #include 在src/lda.cp 文件头加入： #include 重新编译 (4) 语料准备 文件格式是dat。这是最原始的txt文件。你也可以用任何软件存成txt文件之后，直接把后缀改成dat就行。 文件内容: 第1行是你总共的文章篇数 第2行到第M行就是你的那些文章，每篇文章占一行。对于英文来说，每个词之间已经用空格分开了，但是中文不行，所以你要先对文章进行分词和去停用词。 注意:文章格式是ANSI，文章中不能有空行 (5) 运行 执行命令lda -est [-alpha ] [-beta ] [-ntopics ] [-niters ] [-savestep ] [-twords ] -dfile 例子:src/lda -est -alpha 0.5 -beta 0.1 -ntopics 100 -niters 1000 -savestep 100 -twords 20 -dfile /home/leichen/LDA/data.dat 参数alpha是0.5（这个可以先不管），参数beta是0.1（这个也可以先不管），产生100个topic，运算迭代1000次，每迭代100次之后的结果都保存出来，每个topic包含出现概率最大的前20个词，要运算的文件是/home/leichen/LDA/data.dat (6) 结果 结果文件存在你的测试文件所在的目录: model-final.others 设置的参数 model-final.phi 每个主题下的词概率分布 model-final.tassign 每篇文章的各个词被指定的主题编号 model-final.theta 每篇文章的主题概率分布 model-final.twords 每个主题下的前20个主题词 wordmap.txt 词典 "},"代码Demo/matplotlib绘图示例/matplotlib基本绘图示例.html":{"url":"代码Demo/matplotlib绘图示例/matplotlib基本绘图示例.html","title":"matplotlib基本绘图示例","keywords":"","body":"1、学习示例 1.1 pylab库画图 import pylab as plb import numpy as np plb.figure(figsize=(8,6), dpi=80) X = np.linspace(-np.pi,np.pi,256,endpoint=True) (C,S)=np.cos(X),np.sin(X) # 绘制余弦曲线，使用蓝色的、连续的、宽度为 1 （像素）的线条 plb.plot(X, C, color=\"blue\", linewidth=1.0, linestyle=\"-\") plb.plot(X,S,color=\"red\",linewidth=1.0,linestyle=\"-\") plb.show() pyplot库画图 import matplotlib.pyplot as plt import numpy as np X = np.linspace(-np.pi,np.pi,256,endpoint=True) (C,S)=np.cos(X),np.sin(X) plt.figure(figsize=(8,6), dpi=80) plt.subplot(111) #绘制余弦 plt.plot(X, C, color=\"blue\", linewidth=2.0, linestyle=\"-\",label=\"cosine\") #绘制正弦 plt.plot(X, S, color=\"red\", linewidth=2.0, linestyle=\"-\",label=\"sine\") #边界设置得不好，所以有些地方看得不是很清楚 xmin ,xmax = X.min(), X.max() ymin, ymax = C.min(), C.max() dx = (xmax - xmin) * 0.2 dy = (ymax - ymin) * 0.2 #设置x轴上下限 plt.xlim(xmin - dx, xmax + dx) # 设置横轴记号 plt.xticks(np.linspace(-4,4,9,endpoint=True)) # 设置纵轴的上下限 plt.ylim(ymin - dy, ymax + dy) # 设置纵轴记号 plt. yticks(np.linspace(-1,1,5,endpoint=True)) #我们讨论正弦和余弦函数的时候，通常希望知道函数在 ±π±π 和 ±π2±π2 的值 plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$', r'$-\\pi/2$', r'$0$', r'$+\\pi/2$', r'$+\\pi$']) plt.yticks([-1, 0, +1], [r'$-1$', r'$0$', r'$+1$']) # plt.show() 实际上每幅图有四条脊柱（上下左右），为了将脊柱放在图的中间，我们必须将其中的两条（上和右）设置为无色，然后调整剩下的两条到合适的位置——数据空间的 0 点。 ax = plt.gca() ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data',0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data',0)) 我们在图的左上角添加一个图例。为此，我们只需要在 plot 函数里以「键 - 值」的形式增加一个参数。 plt.legend(loc='upper left') 我们希望在 2π/32π/3 的位置给两条函数曲线加上一个注释。首先，我们在对应的函数图像位置上画一个点；然后，向横轴引一条垂线，以虚线标记；最后，写上标签 t = 2*np.pi/3 plt.plot([t,t],[0,np.cos(t)], color ='blue', linewidth=2.5, linestyle=\"--\") plt.scatter([t,],[np.cos(t),], 50, color ='blue') plt.annotate(r'$\\sin(\\frac{2\\pi}{3})=\\frac{\\sqrt{3}}{2}$', xy=(t, np.sin(t)), xycoords='data', xytext=(+10, +30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\")) plt.plot([t,t],[0,np.sin(t)], color ='red', linewidth=2.5, linestyle=\"--\") plt.scatter([t,],[np.sin(t),], 50, color ='red') plt.annotate(r'$\\cos(\\frac{2\\pi}{3})=-\\frac{1}{2}$', xy=(t, np.cos(t)), xycoords='data', xytext=(-90, -50), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\")) plt.show() 散点图 import matplotlib.pyplot as plt import numpy as np n = 1024 X_1 = np.random.normal(0,1,n) Y_1 = np.random.normal(2,3,n) X_2 = np.random.normal(0,1,n) Y_2 = np.random.normal(0,1,n) plt.figure(figsize=(8,6), dpi=80) plt.subplot(111) plt.scatter(X_1,Y_1,color=\"red\") plt.scatter(X_2,Y_2,color=\"blue\") plt.show() 条形图 import matplotlib.pyplot as plt import numpy as np n = 12 X = np.arange(n) Y1 = (1-X/float(n)) * np.random.uniform(0.5,1.0,n) Y2 = (1-X/float(n)) * np.random.uniform(0.5,1.0,n) plt.figure(figsize=(8,6), dpi=80) plt.subplot(111) plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white') for x,y in zip(X,Y1): plt.text(x+0.4, y+0.05, '%.2f' % y, ha='center', va= 'bottom') plt.ylim(-1.25,+1.25) plt.show() 等高线图 import matplotlib.pyplot as plt import numpy as np def f(x,y): return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2) n = 256 x = np.linspace(-3,3,n) y = np.linspace(-3,3,n) X,Y = np.meshgrid(x,y) plt.figure(figsize=(8,6), dpi=80) # plt.subplot(111) plt.contourf(X, Y, f(X,Y), 8, alpha=.75, cmap='jet') C = plt.contour(X, Y, f(X,Y), 8, colors='black', linewidth=0.5) plt.show() 灰度图（Imshow） import matplotlib.pyplot as plt import numpy as np plt.figure(figsize=(8,6), dpi=80) def f(x,y): return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2) n = 10 x = np.linspace(-3,3,4*n) y = np.linspace(-3,3,3*n) X,Y = np.meshgrid(x,y) plt.imshow(f(X,Y)) plt.show() 饼状图 import matplotlib.pyplot as plt import numpy as np plt.figure(figsize=(8,6), dpi=80) n = 20 Z = np.random.uniform(0,1,n) plt.pie(Z) plt.show() 量场图（Quiver Plots） import matplotlib.pyplot as plt import numpy as np plt.figure(figsize=(8,6), dpi=80) n = 8 X,Y = np.mgrid[0:n,0:n] plt.quiver(X,Y) plt.show() 网格 import matplotlib.pyplot as plt import numpy as np plt.figure(figsize=(8,6), dpi=80) y = np.arange(1, 5) plt.plot(y , y+2) plt.grid() # == plt.grid(True) plt.grid(color='b' , linewidth='0.3' ,linestyle='--') plt.show() 多重网络 代码说明： 1、将整个表按照 2*2 划分 2、前两个简单, 分别是 (2, 2, 1) 和 (2, 2, 2) 3、但是第三个图呢, 他占用了 (2, 2, 3) 和 (2, 2, 4) 4、显示需要对其重新划分, 按照 2 * 1 划分 5、前两个图占用了 (2, 1, 1) 的位置 6、因此第三个图占用了 (2, 1, 2) 的位置 import numpy as np import matplotlib.pyplot as plt def f(t):return np.exp(-t) * np.cos(2 * np.pi * t) t1 = np.arange(0, 5, 0.1) t2 = np.arange(0, 5, 0.02) plt.figure(figsize=(8,6), dpi=80) plt.subplot(2,2,1) plt.plot(t1, f(t1), 'bo', t2, f(t2), 'r--') plt.subplot(2,2,2) plt.plot(t2, np.cos(2 * np.pi * t2), 'r--') plt.subplot(2,1,2) plt.plot([1, 2, 3, 4], [1, 4, 9, 16]) plt.show() 3D图 import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(8,6), dpi=80) ax = Axes3D(fig) X = np.arange(-4, 4, 0.25) Y = np.arange(-4, 4, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='hot') plt.show() "},"代码Demo/sklearn聚类/sklearn聚类.html":{"url":"代码Demo/sklearn聚类/sklearn聚类.html","title":"sklearn聚类demo","keywords":"","body":"K-means聚类 K-means参数说明 sklearn.cluster.KMeans(n_clusters=8, init='k-means++', n_init=10, max_iter=300, tol=0.0001, precompute_distances='auto', verbose=0, random_state=None, copy_x=True, n_jobs=1, algorithm='auto' ) 参数的意义： n_clusters:簇的个数，即你想聚成几类 init: 初始簇中心的获取方法 n_init: 获取初始簇中心的更迭次数，为了弥补初始质心的影响，算法默认会初始10个质心，实现算法，然后返回最好的结果。 max_iter: 最大迭代次数（因为kmeans算法的实现需要迭代） tol: 容忍度，即kmeans运行准则收敛的条件 precompute_distances：是否需要提前计算距离，这个参数会在空间和时间之间做权衡，如果是True 会把整个距离矩阵都放到内存中，auto 会默认在数据样本大于featurs*samples 的数量大于12e6 的时候False,False 时核心实现的方法是利用Cpython 来实现的 verbose: 冗长模式（不太懂是啥意思，反正一般不去改默认值） random_state: 随机生成簇中心的状态条件。 copy_x: 对是否修改数据的一个标记，如果True，即复制了就不会修改数据。bool 在scikit-learn 很多接口中都会有这个参数的，就是是否对输入数据继续copy 操作，以便不修改用户的输入数据。这个要理解Python 的内存机制才会比较清楚。 n_jobs: 并行设置 algorithm: kmeans的实现算法，有：’auto’, ‘full’, ‘elkan’, 其中 ‘full’表示用EM方式实现 虽然有很多参数，但是都已经给出了默认值。所以我们一般不需要去传入这些参数,参数的。可以根据实际需要来调用。 代码 from sklearn.cluster import KMeans import numpy as np 获取数据 def get_datalist(file_path): vecs_list=[] word_list = [] with open(file_path,\"r\") as file: for line in file: line_split=line.replace(\"\\n\",\"\").strip().split(\" \") word = line_split[0] vec_list = [float(data) for data in line_split[1:]] word_list.append(word) vecs_list.append(vec_list) return word_list,vecs_list file_path = \"/Users/xiachi/PycharmProjects/credit_card/test/ls/domain_word.vec\" word_list,vecs_list = get_datalist(file_path) vecs_matrix = np.matrix(vecs_list) print(vecs_matrix.shape) (1693, 200) 聚类个数和inertia的关系 # print(\"开始训练....\") # for num in range(20,100): # # num_clusters = 30 # km = KMeans(n_clusters=num,algorithm=\"full\",max_iter=600) # km.fit(vecs_matrix) # inertia = km.inertia_ # 获取聚类准则的总和 # print(\"聚类个数:%s,inertia值为:%s:\"%(str(num),str(inertia))) # print(\"训练结束！\") 指定簇个数训练 num_clusters = 70 km = KMeans(n_clusters=num_clusters,algorithm=\"full\",max_iter=600) km.fit(vecs_matrix) label_pred = km.labels_ #获取聚类标签 centroids = km.cluster_centers_ #获取聚类中心 inertia = km.inertia_ # 获取聚类准则的总和 ziped_list = zip(word_list,list(label_pred)) with open(\"result.txt\",\"w+\") as file: for (word,label) in ziped_list: wtr_str = str(word)+\"\\t\"+str(label)+\"\\n\" file.write(wtr_str) 可视化聚类结果 from sklearn.manifold import TSNE import matplotlib.pyplot as plt tsne=TSNE() X_Y = tsne.fit_transform(vecs_matrix) #进行数据降维,降成两维 plt.scatter(X_Y[:, 0], X_Y[:, 1],c=label_pred) plt.show() 层次聚类 算法说明 AgglomerativeClustering是scikit-learn提供的层级聚类算法模型，其原型为： class sklearn.cluster.AgglomerativeClustering( n_clusters=2, affinity=’euclidean’, memory=None, connectivity=None, compute_full_tree=’auto’, linkage=’ward’, pooling_func=) 参数 n_clusters：一个整数，指定分类簇的数量 connectivity：一个数组或者可调用对象或者None，用于指定连接矩阵 affinity：一个字符串或者可调用对象，用于计算距离。可以为：’euclidean’，’l1’，’l2’，’mantattan’，’cosine’，’precomputed’，如果linkage=’ward’，则affinity必须为’euclidean’ memory：用于缓存输出的结果，默认为不缓存 n_components：在 v-0.18中移除 compute_full_tree：通常当训练了n_clusters后，训练过程就会停止，但是如果compute_full_tree=True，则会继续训练从而生成一颗完整的树 linkage：一个字符串，用于指定链接算法 ‘ward’：单链接single-linkage，采用dmin ‘complete’：全链接complete-linkage算法，采用dmax ‘average’：均连接average-linkage算法，采用davg pooling_func：一个可调用对象，它的输入是一组特征的值，输出是一个数 属性 labels：每个样本的簇标记 nleaves：分层树的叶节点数量 n_components：连接图中连通分量的估计值 children：一个数组，给出了每个非节点数量 方法 fit(X[,y])：训练样本 fit_predict(X[,y])：训练模型并预测每个样本的簇标记 代码示例 from time import time import numpy as np from scipy import ndimage from matplotlib import pyplot as plt from sklearn import manifold, datasets digits = datasets.load_digits(n_class = 10) X = digits.data y = digits.target n_samples, n_features = X.shape np.random.seed(0) def nudge_image(X, y): shift = lambda x: ndimage.shift(x.reshape((8, 8)), .3 * np.random.normal(size = 2), mode = 'constant').ravel() X = np.concatenate([X, np.apply_along_axis(shift, 1, X)]) Y = np.concatenate([y, y], axis = 0) return X, Y X, y = nudge_image(X, y) def plot_clustering(X_red, labels, title = None): x_min, x_max = np.min(X_red, axis = 0), np.max(X_red, axis = 0) X_red = (X_red - x_min) / (x_max - x_min) plt.figure(figsize = (6, 4)) for i in range(X_red.shape[0]): plt.text(X_red[i,0], X_red[i,1], str(y[i]), color = plt.cm.spectral(labels[i]/10.), fontdict = {'weight': 'bold', 'size': 9}) plt.xticks([]) plt.yticks([]) if title is not None: plt.title(title, size = 17) plt.axis('off') plt.tight_layout() print(\"Computing embedding\" ) X_red = manifold.SpectralEmbedding(n_components = 2).fit_transform(X) print(\"Done!\") from sklearn.cluster import AgglomerativeClustering for linkage in ('ward', 'average', 'complete'): clustering = AgglomerativeClustering(linkage = linkage, n_clusters = 10) t0 = time() clustering.fit(X_red) print(\"%s : %.2fs\" % (linkage, time() - t0)) plot_clustering(X_red, X, clustering.labels_, \"%s linkage\" % linkage) plt.show() Computing embedding Done! ward : 0.29s average : 0.27s complete : 0.24s 账单数据进行层次聚类 数据加载 import numpy as np def get_datalist(file_path): vecs_list=[] word_list = [] with open(file_path,\"r\") as file: for line in file: line_split=line.replace(\"\\n\",\"\").strip().split(\" \") word = line_split[0] vec_list = [float(data) for data in line_split[1:]] word_list.append(word) vecs_list.append(vec_list) return word_list,vecs_list file_path = \"/Users/xiachi/PycharmProjects/credit_card/test/ls/domain_word.vec\" word_list,vecs_list = get_datalist(file_path) vecs_matrix = np.matrix(vecs_list) print(vecs_matrix.shape) (1693, 200) 开始聚类 from sklearn.cluster import AgglomerativeClustering linkages=['ward','complete','average'] clustering = AgglomerativeClustering(linkage=\"ward\",n_clusters = 120) clustering.fit(vecs_matrix) predicted_lables=clustering.fit_predict(vecs_matrix) print(len(predicted_lables)) 1693 写入文件 with open(\"hi_result.txt\",\"w+\") as file: for i,word in enumerate(word_list): wtr=word+\"\\t\"+str(list(predicted_lables)[i]) file.write(wtr+\"\\n\") 可视化聚类结果 from sklearn.manifold import TSNE from matplotlib import pyplot as plt tsne=TSNE() X_Y = tsne.fit_transform(vecs_matrix) #进行数据降维,降成两维 plt.scatter(X_Y[:, 0], X_Y[:, 1],c=predicted_lables) plt.show() def plot_clustering(X_red, labels, title = None): x_min, x_max = np.min(X_red, axis = 0), np.max(X_red, axis = 0) X_red = (X_red - x_min) / (x_max - x_min) plt.figure(figsize = (6, 4)) for i in range(X_red.shape[0]): plt.text(X_red[i,0], X_red[i,1], str(labels[i]),color = plt.cm.spectral(labels[i]/10.), fontdict = {'weight': 'bold', 'size': 9}) plt.xticks([]) plt.yticks([]) if title is not None: plt.title(title, size = 17) plt.axis('off') plt.tight_layout() plot_clustering(X_Y,predicted_lables,\"ward\") plt.show() DBSCAN聚类 聚类 #数据在层次聚类中加载了 from sklearn.cluster import DBSCAN y_pred = DBSCAN(eps = 0.4, min_samples = 10).fit_predict(vecs_matrix) print(len(list(set(y_pred)))) 1 可视化聚类结果 from sklearn.manifold import TSNE from matplotlib import pyplot as plt tsne=TSNE() X_Y = tsne.fit_transform(vecs_matrix) #进行数据降维,降成两维 plt.scatter(X_Y[:, 0], X_Y[:, 1],c=y_pred) plt.show() "},"gitbook_files/introduction.html":{"url":"gitbook_files/introduction.html","title":"前言","keywords":"","body":"前言 主要记录GitBook的安装配置以及一些插件信息, 下面是GitBook的一些资源 GitBook主页 Github地址 GitBook编辑器 GitBook Toolchain Documentation GitBook Documentation 如若转载请标明出处. "},"gitbook_files/installation.html":{"url":"gitbook_files/installation.html","title":"安装","keywords":"","body":"GitBook安装 下面介绍在本地如何安装 GitBook，如果不需要本地调试 & 不需要获得生成的 html 文件，可以直接使用 官网 提供的服务。 环境要求 通过NPM安装 编辑书籍 预览书籍 环境要求 NodeJS(v4.0.0及以上) 通过NPM安装 运行下面的命令进行安装 npm install gitbook-cli -g 其中gitbook-cli是gitbook的一个命令行工具, 通过它可以在电脑上安装和管理gitbook的多个版本. 编辑书籍 gitbook 官方已经提供了一个本地的编辑器, 使用它可以方便的编写书籍(不需要手动的写SUMMARY.md), 并且支持windows、mac、linux 三种平台, 所以强烈建议使用编辑器编写书籍. 预览书籍 使用下列命令会运行一个服务器, 通过http://localhost:4000/可以预览书籍 gitbook serve 运行该命令后会在书籍的文件夹中生成一个 _book 文件夹, 里面的内容即为生成的 html 文件. 我们可以使用下面命令来生成网页而不开启服务器 gitbook build "},"gitbook_files/commands.html":{"url":"gitbook_files/commands.html","title":"命令","keywords":"","body":"命令 这里主要介绍一下 GitBook 的命令行工具 gitbook-cli 的一些命令, 首先说明两点: gitbook-cli 和 gitbook 是两个软件 gitbook-cli 会将下载的 gitbook 的不同版本放到 ~/.gitbook中, 可以通过设置GITBOOK_DIR环境变量来指定另外的文件夹 列出gitbook所有的命令 gitbook help 输出gitbook-cli的帮助信息 gitbook --help 生成静态网页 gitbook build 生成静态网页并运行服务器 gitbook serve 生成时指定gitbook的版本, 本地没有会先下载 gitbook build --gitbook=2.0.1 列出本地所有的gitbook版本 gitbook ls 列出远程可用的gitbook版本 gitbook ls-remote 安装对应的gitbook版本 gitbook fetch 标签/版本号 更新到gitbook的最新版本 gitbook update 卸载对应的gitbook版本 gitbook uninstall 2.0.1 指定log的级别 gitbook build --log=debug 输出错误信息 gitbook builid --debug "},"gitbook_files/structure.html":{"url":"gitbook_files/structure.html","title":"目录结构","keywords":"","body":"目录结构 GitBook 基本的目录结构如下所示 . ├── book.json ├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | └── something.md └── chapter-2/ ├── README.md └── something.md 这里主要讲下 GitBook 预定义的几个文件的作用 book.json 存放配置信息，在下一章中所讲的配置信息都是在这个文件里定义的，关于该文件的配置可以看 配置 这个章节。 Summary 概要文件主要存放 GitBook 的文件目录信息，左侧的目录就是根据这个文件来生成的，默认对应的文件是 SUMMARY.md，可以在 book.json 重新定义该文件的对应值。它通过 Markdown 中的列表语法来表示文件的父子关系，下面是一个简单的示例： # Summary * [Introduction](README.md) * [Part I](part1/README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) * [Part II](part2/README.md) * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) 这个配置对应的目录结构如下所示: 我们通过使用 标题 或者 水平分割线 标志将 GitBook 分为几个不同的部分 # Summary ### Part I * [Introduction](README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) ### Part II * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) ---- * [Last part without title](part3/title.md) 这个配置对应的目录结构如下所示： Glossary 词汇表文件，默认对应的文件是 GLOSSARY.md。该文件主要存储词汇信息，如果在其他页面中出现了该文件中的词汇，鼠标放到词汇上会给出词汇示意，可以将鼠标移到下面两个词汇上看下效果。 Git    Markdown Glossary 文件的格式如下所示： ## Git 分散式版本控制软件 ## Markdown Aaron Swartz 跟John Gruber共同设计的排版语言 "},"gitbook_files/settings.html":{"url":"gitbook_files/settings.html","title":"配置","keywords":"","body":"GitBook配置 记录Gitbook的一些配置信息 title - 标题 author - 作者信息 description - 书本描述 language - 使用的语言 gitbook - 指定gitbook版本 root - 指定存放 GitBook 文件的根目录 links - 在侧边栏添加链接 styles - 自定义样式 plugins - 插件 pluginsConfig - 插件配置 structure - 设置 Readme, Summary, Glossary等对应的文件 title 设置书本的标题 \"title\" : \"Gitbook Use\" author 作者的相关信息 \"author\" : \"zhangjikai\" description 本书的简单描述 \"description\" : \"记录Gitbook的配置和一些插件的使用\" language Gitbook使用的语言, 版本2.6.4中可选的语言如下： en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw 配置使用简体中文 \"language\" : \"zh-hans\", gitbook 指定使用的gitbook版本 \"gitbook\" : \"3.2.2\", \"gitbook\" : \">=3.0.0\" root 指定存放 GitBook 文件（除了 book.json）的根目录 \"root\": \".\" links 在左侧导航栏添加链接信息 \"links\" : { \"sidebar\" : { \"Home\" : \"http://zhangjikai.com\" } } styles 自定义页面样式， 默认情况下各generator对应的css文件 \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 例如使 标签有下边框， 可以在website.css中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } plugins 配置使用的插件 \"plugins\": [ \"disqus\" ] 添加新插件之后需要运行gitbook install来安装新的插件 Gitbook默认带有5个插件： highlight search sharing font-settings livereload 如果要去除自带的插件， 可以在插件名称前面加- \"plugins\": [ \"-search\" ] pluginsConfig 配置插件的属性 \"pluginsConfig\": { \"fontsettings\": { \"theme\": \"sepia\", \"family\": \"serif\", \"size\": 1 } } structure 指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值： 变量 含义和默认值 structure.readme Readme file name (defaults to README.md) structure.summary Summary file name (defaults to SUMMARY.md) structure.glossary Glossary file name (defaults to GLOSSARY.md) structure.languages Languages file name (defaults to LANGS.md) "},"gitbook_files/plugins.html":{"url":"gitbook_files/plugins.html","title":"插件","keywords":"","body":"GitBook 插件 记录一些实用的插件, 如果要指定插件的版本可以使用 plugin@0.3.1。下面的插件在 GitBook 的 3.2.3 版本中可以正常工作，因为一些插件可能不会随着 GitBook 版本的升级而升级，即下面的插件可能不适用高版本的 GitBook，所以这里指定了 GitBook 的版本。另外本文记录的插件在 Linux 下都是可以正确工作的，windows 系统没有测试。这里只是列举了一部分插件，如果有其它的需求，可以到 插件官网 区搜索相关插件。 Disqus - Disqus 评论 Search Plus - 支持中文搜索 Prsim - 使用 Prism.js 高亮代码 Advanced Emoji - 支持 emoji 表情 Github - 添加github图标 Github Buttons - 添加项目在 Github 上的 star、fork、watch 信息 Ace Plugin - 支持ace Emphasize - 为文字加上底色 KaTex - 支持数学公式 Include Codeblock - 用代码块显示包含文件的内容 Splitter - 使侧边栏的宽度可以自由调节 Mermaid-gb3 - 支持渲染 Mermaid 图表 Puml - 支持渲染 uml 图 Graph - 使用 function-plot 绘制数学函数图 Chart - 绘制图形 Sharing-plus - 分享当前页面 Tbfed-pagefooter - 为页面添加页脚 Expandable-chapters-small - 使左侧的章节目录可以折叠 Sectionx - 将页面分块显示 GA - Google 统计 3-ba - 百度统计 Donate - 打赏插件 Local Video - 使用 Video.js 播放本地视频 Simple-page-toc - 自动生成本页的目录结构 Anchors - 添加 Github 风格的锚点 Anchor-navigation-ex - 添加Toc到侧边悬浮导航以及回到顶部按钮 Edit Link - 链接到当前页源文件上 Sitemap-general - 生成sitemap Favicon - 更改网站的 favicon.ico Todo - 添加 Todo 功能 Terminal - 模拟终端样式 Copy-code-button - 为代码块添加复制按钮 Alerts - 添加不同 alerts 样式的 blockquotes Include-csv - 显示 csv 文件内容 Musicxml - 支持 musicxml 格式的乐谱渲染 Klipse - 集成 Kplise (online code evaluator) Versions-select - 添加版本选择的下拉菜单 Rss - 添加 rss 订阅功能 Disqus 添加disqus评论 插件地址 \"plugins\": [ \"disqus\" ], \"pluginsConfig\": { \"disqus\": { \"shortName\": \"gitbookuse\" } } Search Plus 支持中文搜索, 需要将默认的 search 和 lunr 插件去掉。 插件地址 { \"plugins\": [\"-lunr\", \"-search\", \"search-plus\"] } Prism 使用 Prism.js 为语法添加高亮显示，需要将 highlight 插件去掉。该插件自带的主题样式较少，可以再安装 prism-themes 插件，里面多提供了几种样式，具体的样式可以参考 这里，在设置样式时要注意设置 css 文件名，而不是样式名。 Prism 插件地址    prism-themes 插件地址 { \"plugins\": [ \"prism\", \"-highlight\" ], \"pluginsConfig\": { \"prism\": { \"css\": [ \"prism-themes/themes/prism-base16-ateliersulphurpool.light.css\" ] } } } 如果需要修改背景色、字体大小等，可以在 website.css 定义 pre[class*=\"language-\"] 类来修改，下面是一个示例： pre[class*=\"language-\"] { border: none; background-color: #f7f7f7; font-size: 1em; line-height: 1.2em; } Advanced Emoji 支持emoji表情 emoij表情列表插件地址 \"plugins\": [ \"advanced-emoji\" ] 使用示例： :bowtie: :smile: :laughing: :blush: :smiley: :relaxed: Github 添加github图标 插件地址 \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/zhangjikai\" } } Github Buttons 添加项目在 github 上的 star，watch，fork情况 插件地址 { \"plugins\": [ \"github-buttons\" ], \"pluginsConfig\": { \"github-buttons\": { \"repo\": \"zhangjikai/gitbook-use\", \"types\": [ \"star\", \"watch\", \"fork\" ], \"size\": \"small\" } } } Ace Plugin 插件地址 使 GitBook 支持ace 。默认情况下，line-height 为 1，会使代码显得比较挤，而作者好像没提供修改行高的选项，如果需要修改行高，可以到 node_modules -> github-plugin-ace -> assets -> ace.js 中加入下面两行代码 (30 行左右的位置)： editor.container.style.lineHeight = 1.25; editor.renderer.updateFontSize(); 不过上面的做法有个问题就是，每次使用 gitbook install 安装新的插件之后，代码又会重置为原来的样子。另外可以在 website.css 中加入下面的 css 代码来指定 ace 字体的大小 .aceCode { font-size: 14px !important; } 使用插件： \"plugins\": [ \"ace\" ] 使用示例: // This is a hello world program for C. #include int main(){ printf(\"Hello World!\"); return 1; } Emphasize 为文字加上底色 插件地址 \"plugins\": [ \"emphasize\" ] 使用示例: This text is highlighted ! This text is highlighted with markdown! This text is highlighted in green! This text is highlighted in red! This text is highlighted with a custom color! KaTex 为了支持数学公式, 我们可以使用KaTex和MathJax插件, 官网上说Katex速度要快于MathJax 插件地址MathJax使用LaTeX语法编写数学公式教程 \"plugins\": [ \"katex\" ] 使用示例: When a≠0a \\ne 0a≠0, there are two solutions to (ax2+bx+c=0)(ax^2 + bx + c = 0)(ax​2​​+bx+c=0) and they are x=−b±b2−4ac2a.x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.x=​2a​​−b±√​b​2​​−4ac​​​​​. ∫−∞∞g(x)dx \\int_{-\\infty}^\\infty g(x) dx ∫​−∞​∞​​g(x)dx 13 1 \\over 3 ​3​​1​​ Include Codeblock 使用代码块的格式显示所包含文件的内容. 该文件必须存在。插件提供了一些配置，可以区插件官网查看。如果同时使用 ace 和本插件，本插件要在 ace 插件前面加载。 插件地址 { \"plugins\": [ \"include-codeblock\" ], \"pluginsConfig\": { \"include-codeblock\": { \"template\": \"ace\", \"unindent\": \"true\", \"theme\": \"monokai\" } } } 使用示例: /* CSS for website */ h1 , h2{ border-bottom: 1px solid #EFEAEA; padding-bottom: 3px; } .markdown-section>:first-child { margin-top: 0!important; } .page-wrapper { margin-top: -1.275em; } .book .book-body .page-wrapper .page-inner section.normal { min-height:350px; margin-bottom: 30px; } .book .book-body .page-wrapper .page-inner section.normal hr { height: 0px; padding: 0; margin: 1.7em 0; overflow: hidden; background-color: #e7e7e7; border-bottom: 1px dotted #e7e7e7; } .video-js { width:100%; height: 100%; } pre[class*=\"language-\"] { border: none; background-color: #f7f7f7; font-size: 1em; line-height: 1.2em; } .book .book-body .page-wrapper .page-inner section.normal { font-size: 16px; font-family: \"ubuntu\", \"Tahoma\", \"Microsoft YaHei\", arial, sans-serif; } .aceCode { font-size: 14px !important; } input[type=checkbox]{ margin-left: -2em; } .page-footer span{ font-size: 12px; } .page-footer .copyright { float: left; } .body, html { overflow-y: hidden; } .versions-select select { height: 2em; line-height: 2em; border-radius: 4px; background: #efefef; } Splitter 使侧边栏的宽度可以自由调节 插件地址 \"plugins\": [ \"splitter\" ] Mermaid-gb3 支持渲染Mermaid图表插件地址 \"plugins\": [ \"mermaid-gb3\" ] 使用示例: graph TD; A-->B; A-->C; B-->D; C-->D; Puml 使用 PlantUML 展示 uml 图。 插件地址PlantUML 地址 { \"plugins\": [\"puml\"] } 使用示例： {% plantuml %} Class Stage Class Timeout { +constructor:function(cfg) +timeout:function(ctx) +overdue:function(ctx) +stage: Stage } Stage 效果如下所示： Graph 使用 function-plot 绘制数学函数图。 插件地址function-plot { \"plugins\": [ \"graph\" ], } 下面是一个示例，需要注意的是 {% graph %} 块中的内容必须是合法的 JSON 格式。 {% graph %} { \"title\": \"1/x * cos(1/x)\", \"grid\": true, \"xAxis\": { \"domain\": [0.01, 1] }, \"yAxis\": { \"domain\": [-100, 100] }, \"data\": [{ \"fn\": \"1/x * cos(1/x)\", \"closed\": true }] } {% endgraph %} 效果如下所示： functionPlot({\"title\":\"1/x * cos(1/x)\",\"grid\":true,\"xAxis\":{\"domain\":[0.01,1]},\"yAxis\":{\"domain\":[-100,100]},\"data\":[{\"fn\":\"1/x * cos(1/x)\",\"closed\":true}],\"target\":\"#plugin-graph-0\"}); Chart 使用 C3.js 或者 Highcharts 绘制图形。 插件地址C3.jshighcharts { \"plugins\": [ \"chart\" ], \"pluginsConfig\": { \"chart\": { \"type\": \"c3\" } } } type 可以是 c3 或者 highcharts, 默认是 c3. 下面是一个示例： {% chart %} { \"data\": { \"type\": \"bar\", \"columns\": [ [\"data1\", 30, 200, 100, 400, 150, 250], [\"data2\", 50, 20, 10, 40, 15, 25] ], \"axes\": { \"data2\": \"y2\" } }, \"axis\": { \"y2\": { \"show\": true } } } {% endchart %} 效果如下所示： c3.generate({\"data\":{\"type\":\"bar\",\"columns\":[[\"data1\",30,200,100,400,150,250],[\"data2\",50,20,10,40,15,25]],\"axes\":{\"data2\":\"y2\"}},\"axis\":{\"y2\":{\"show\":true}},\"bindto\":\"#plugin-chart-1\"}); Sharing-plus 分享当前页面，比默认的 sharing 插件多了一些分享方式。 插件地址 plugins: [\"-sharing\", \"sharing-plus\"] 配置: \"pluginsConfig\": { \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": true, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": true, \"linkedin\": true, \"messenger\": false, \"pocket\": false, \"qq\": false, \"qzone\": true, \"stumbleupon\": false, \"twitter\": false, \"viber\": false, \"vk\": false, \"weibo\": true, \"whatsapp\": false, \"all\": [ \"facebook\", \"google\", \"twitter\", \"weibo\", \"instapaper\", \"linkedin\", \"pocket\", \"stumbleupon\" ] } } Tbfed-pagefooter 为页面添加页脚 插件地址 \"plugins\": [ \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy zhangjikai.com 2017\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } Expandable-chapters-small 使左侧的章节目录可以折叠 插件地址 plugins: [\"expandable-chapters-small\"] Sectionx 将页面分块显示，标签的 tag 最好是使用 b 标签，如果使用 h1-h6 可能会和其他插件冲突。插件地址 { \"plugins\": [ \"sectionx\" ], \"pluginsConfig\": { \"sectionx\": { \"tag\": \"b\" } } } 使用示例 Insert markdown content here (you should start with h3 if you use heading). GA Google 统计插件地址 \"plugins\": [ \"ga\" ], \"pluginsConfig\": { \"ga\": { \"token\": \"UA-XXXX-Y\" } } 3-ba 百度统计插件地址 { \"plugins\": [\"3-ba\"], \"pluginsConfig\": { \"3-ba\": { \"token\": \"xxxxxxxx\" } } } Donate 打赏插件插件地址 \"plugins\": [ \"donate\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"https://zhangjikai.com/resource/weixin.png\", \"alipay\": \"https://zhangjikai.com/resource/alipay.png\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" } } Local Video 使用Video.js 播放本地视频插件地址 \"plugins\": [ \"local-video\" ] 使用示例：为了使视频可以自适应，我们指定视频的width为100%，并设置宽高比为16:9，如下面所示 {% raw %} To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5 video {% endraw %} 另外我们还要再配置下css，即在website.css中加入 .video-js { width:100%; height: 100%; } To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5 video Simple-page-toc 自动生成本页的目录结构。另外 GitBook 在处理重复的标题时有些问题，所以尽量不适用重复的标题。 插件地址 { \"plugins\" : [ \"simple-page-toc\" ], \"pluginsConfig\": { \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true } } } 使用方法: 在需要生成目录的地方加上 Anchors 添加 Github 风格的锚点样式 插件地址 \"plugins\" : [ \"anchors\" ] Anchor-navigation-ex 添加Toc到侧边悬浮导航以及回到顶部按钮。需要注意以下两点： 本插件只会提取 h[1-3] 标签作为悬浮导航 只有按照以下顺序嵌套才会被提取# h1 ## h2 ### h3 必须要以 h1 开始，直接写 h2 不会被提取 ## h2 插件地址 { \"plugins\": [ \"anchor-navigation-ex\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"isRewritePageTitle\": true, \"isShowTocTitleIcon\": true, \"tocLevel1Icon\": \"fa fa-hand-o-right\", \"tocLevel2Icon\": \"fa fa-hand-o-right\", \"tocLevel3Icon\": \"fa fa-hand-o-right\" } } } Edit Link 如果将 GitBook 的源文件保存到github或者其他的仓库上，使用该插件可以链接到当前页的源文件上。插件地址 \"plugins\": [\"edit-link\"], \"pluginsConfig\": { \"edit-link\": { \"base\": \"https://github.com/USER/REPO/edit/BRANCH\", \"label\": \"Edit This Page\" } } Sitemap-general 生成sitemap插件地址 { \"plugins\": [\"sitemap-general\"], \"pluginsConfig\": { \"sitemap-general\": { \"prefix\": \"http://gitbook.zhangjikai.com\" } } } Favicon 更改网站的 favicon.ico插件地址 { \"plugins\": [ \"favicon\" ], \"pluginsConfig\": { \"favicon\": { \"shortcut\": \"assets/images/favicon.ico\", \"bookmark\": \"assets/images/favicon.ico\", \"appleTouch\": \"assets/images/apple-touch-icon.png\", \"appleTouchMore\": { \"120x120\": \"assets/images/apple-touch-icon-120x120.png\", \"180x180\": \"assets/images/apple-touch-icon-180x180.png\" } } } } Todo 添加 Todo 功能。默认的 checkbox 会向右偏移 2em，如果不希望偏移，可以在 website.css 里加上下面的代码: input[type=checkbox]{ margin-left: -2em; } 插件地址 \"plugins\": [\"todo\"] 使用示例： [ ] write some articles [x] drink a cup of tea Terminal 模拟终端显示，主要用于显示命令以及多行输出，不过写起来有些麻烦。 插件地址 { \"plugins\": [ \"terminal\" ], \"pluginsConfig\": { \"terminal\": { \"copyButtons\": true, \"fade\": false, \"style\": \"flat\" } } } 现在支持 6 种标签： command: Command \"executed\" in the terminal. delimiter: Sequence of characters between the prompt and the command. error: Error message. path: Directory path shown in the prompt. prompt: Prompt of the user. warning: Warning message. 标签的使用格式如下所示： **[ 内容] 为了使标签正常工作，需要在代码块的第一行加入 **[termial] 标记，下面是一个完整的示例： ``` **[terminal] **[prompt foo@joe]**[path ~]**[delimiter $ ]**[command ./myscript] Normal output line. Nothing special here... But... You can add some colors. What about a warning message? **[warning [WARNING] The color depends on the theme. Could look normal too] What about an error message? **[error [ERROR] This is not the error you are looking for] ``` 效果如下所示： **[terminal] **[prompt foo@joe]**[path ~]**[delimiter $ ]**[command ./myscript] Normal output line. Nothing special here... But... You can add some colors. What about a warning message? **[warning [WARNING] The color depends on the theme. Could look normal too] What about an error message? **[error [ERROR] This is not the error you are looking for] terminal 支持下面 5 种样式，如果需要更换样式，在 pluginsConfig 里配置即可。 black: Just that good old black terminal everybody loves. classic: Looking for green color font over a black background? This is for you. flat: Oh, flat colors. I love flat colors. Everything looks modern with them. ubuntu: Admit it or not, but Ubuntu have a good looking terminal. white: Make your terminal to blend in with your GitBook. Copy-code-button 为代码块添加复制的按钮。 插件地址 { \"plugins\": [\"copy-code-button\"] } 效果如下图所示： Alerts 添加不同 alerts 样式的 blockquotes，目前包含 info, warning, danger 和 success 四种样式。 插件地址 { \"plugins\": [\"alerts\"] } 下面是使用示例： Info styling > **[info] For info** > > Use this for infomation messages. Warning styling > **[warning] For warning** > > Use this for warning messages. Danger styling > **[danger] For danger** > > Use this for danger messages. Success styling > **[success] For info** > > Use this for success messages. 效果如下所示： Info styling [info] For info Use this for infomation messages. Warning styling [warning] For warning Use this for warning messages. Danger styling [danger] For danger Use this for danger messages. Success styling [success] For info Use this for success messages. Include-csv 展示 csv 文件。 插件地址 { \"plugins\": [\"include-csv\"] } 使用示例： {% includeCsv src=\"./assets/csv/test.csv\", useHeader=\"true\" %} {% endincludeCsv %} 效果如下所示： ./assets/csv/test.csv产业数值比重第一产业11110.00%第二产业22220.00%第三产业33330.00%第四产业44440.00% Musicxml 支持 musicxml 格式的乐谱渲染。 插件地址musicXML { \"plugins\": [\"musicxml\"] } 下面是一个示例，需要注意的是 block 中的内容必须是一个合法的 musicxml 文件路径，并且不能有换行和空格。 {% musicxml %}assets/musicxml/mandoline - debussy.xml{% endmusicxml %} 效果如下所示 Klipse 集成 Klipse (online code evaluator) 插件地址Klipse { \"plugins\": [\"klipse\"] } klipse 目前支持下面的语言： javascript: evaluation is done with the javascript function eval and pretty printing of the result is done with pretty-format clojure[script]: evaluation is done with Self-Hosted Clojurescript ruby: evaluation is done with Opal C++: evaluation is done with JSCPP python: evaluation is done with Skulpt scheme: evaluation is done with BiwasScheme PHP: evaluation is done with Uniter BrainFuck JSX EcmaScript2017 Google Charts: See Interactive Business Report with Google Charts. 下面是一个使用示例： ```eval-python print [x + 1 for x in range(10)] ``` 效果如下所示： print [x + 1 for x in range(10)] Versions-select 添加版本选择的下拉菜单，针对文档有多个版本的情况。 插件地址 { \"plugins\": [ \"versions-select\" ], \"pluginsConfig\": { \"versions\": { \"options\": [ { \"value\": \"http://gitbook.zhangjikai.com\", \"text\": \"v3.2.2\" }, { \"value\": \"http://gitbook.zhangjikai.com/v2/\", \"text\": \"v2.6.4\" } ] } } } 我们可以自定义 css 来修改 select 的显示样式： .versions-select select { height: 2em; line-height: 2em; border-radius: 4px; background: #efefef; } 效果见左上角。 RSS 添加 rss 订阅功能。 插件地址 { \"plugins\": [ \"rss\" ], \"pluginsConfig\": { \"rss\": { \"title\": \"GitBook 使用教程\", \"description\": \"记录 GitBook 的配置和一些插件的使用\", \"author\": \"Jikai Zhang\", \"feed_url\": \"http://gitbook.zhangjikai.com/rss\", \"site_url\": \"http://gitbook.zhangjikai.com/\", \"managingEditor\": \"me@zhangjikai.com\", \"webMaster\": \"me@zhangjikai.com\", \"categories\": [ \"gitbook\" ] } } } 效果见右上角。 "},"gitbook_files/themes.html":{"url":"gitbook_files/themes.html","title":"主题","keywords":"","body":"主题 目前 GitBook 提供了三类文档： Book 文档、API文档、FAQ文档。我们常用的就是 Book 文档模式，如果我们需要使用 API 文档模式或者 FAQ 文档模式，只需引入文档对应的主题插件即可，下面我们介绍与这三类文档相关的主题插件。 Book theme-default theme-comscore API 文档 FAQ 文档 Book Book 是我们常用的模式，大部分插件也都是针对这个模式做的。下面介绍一下针对 Book 模式的两个主题。 theme-default theme-default 是默认的 Book 主题。将 showLevel 设为 true， 就可以显示标题前面的数字索引，默认不显示。 { \"theme-default\": { \"showLevel\": true } } 在使用该主题的过程中，发现经常会在控制台报下面的错误，没有找到是哪里的原因，官方也一直没有修复。 theme.js:4 Uncaught TypeError: Cannot read property 'split' of undefined 后来在 这里 看到一个解决方法，需要修改本地的 GitBook Theme 模板。下面是具体步骤： 进入 GitBook 默认主题所在的文件夹 用户主目录 -> .gitbook -> versions -> 3.2.2 -> node_modules -> gitbook-plugin-theme-default -> src -> js -> theme，打开 navigation.js，找到 getChapterHash 函数 function getChapterHash($chapter) { var $link = $chapter.children('a'), hash = $link.attr('href').split('#')[1]; if (hash) hash = '#'+hash; return (!!hash)? hash : ''; } 将该函数修改为下面的形式: function getChapterHash($chapter) { var $link = $chapter.children('a'), hash, href, parts; if ($link.length) { href = $link.attr('href') if (href) { parts = href.split('#'); if (parts.length>1) { hash = parts[1]; } } } if (hash) hash = '#'+hash; return (!!hash)? hash : ''; } 回到 gitbook-plugin-theme-default 文件夹，运行 npm install 重新编译文件。 另外在 v3 版本中引入了 part 的概念 (通过标题或者水平分割线将 GitBook 分为几个 part)，所以目录的索引格式为 part-index + article-index。但是很多时候我们可能只有一个 part，并且不希望添加 part-index，即 1.1, 1.2 -> 1, 2。官方说是会在 v4 版本中解决这个问题，如果 v3 版本中希望去掉前面的 part-index，需要我们手动修改 gitbook 的源文件，下面是修改方法： 打开 /.gitbook/versions/3.x.x/lib/models/summaryPart.js 修改第 51 行的内容： // return SummaryArticle.create(article, [level, i + 1].join('.')); return SummaryArticle.create(article, (i + 1) + ''); 这样修改之后会有个问题，即每个 part 都会从 1 开始计数，如下图所示： 对于这个问题，目前的解决方法就是使用不同版本的 GitBook，对 3.2.2 进行了修改， 3.2.3 没有修改，当只有一个 part 的时候使用 3.2.2 的版本，多个 part 的时候使用 3.2.3 的版本。 theme-comscore 为标题添加颜色，如下如所示 插件地址 { \"plugins\": [ \"theme-comscore\" ] } API 文档 GitBook 同样可以编写 API 文档，只需要引入 theme-api 插件 { \"plugins\": [\"theme-api\"], \"pluginsConfig\": { \"theme-api\": { \"theme\": \"dark\" } } } 引入之后会替换默认的样式。下面是 API 文档的样式截图和在线演示： 在线演示    示例源码 使用 GitBook 的 API 文档模式时也可以使用插件，但是因为大部分插件可能针对写书的模式，所以有可能会出现不兼容的现象。 API文档的语法也很简单，因为主要是针对方法的，所以以方法为基本单位，通过下面的语法来定义一个方法 {% method %} 内容区 {% endmethod %} 在内容区里面，通过 {% sample lang=\"lang\" %}来定义一个针对特定语言的演示，通过 {% common %} 标识所有语言共同的部分。可以在 这里 查看完整的示例。 FAQ 文档 theme-faq 插件主要用来制作知识库或者帮助中心，GitBook 的 帮助中心 就是使用的该主题。为了支持中文搜索我们需要引入 search-pro 包。 { \"plugins\": [ \"theme-faq\", \"-lunr\", \"search-pro@^2.0.2\" ] } 下面是该主题的截图以及在线示例： 在线演示    示例源码 编写帮助中心很简单，在 Summary 里配置问题以及答案所在的文件，在对应文件中写入问题的答案即可，下面是一个示例SUMMARY.md # Summary * [什么 is Git](Git.md) * [什么 is Github](Github.md) Git.md Git 是一个分布式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools[6]（一个类似Norton Commander界面的文件管理器）有所不同。 "}}